Metadata-Version: 2.1
Name: pystaq
Version: 3.5
Summary: Python 3 wrapper for staq
Author-email: "softwareQ Inc." <info@softwareq.ca>
License: MIT
Project-URL: homepage, https://github.com/softwareqinc/staq
Project-URL: repository, https://github.com/softwareqinc/staq.git
Platform: linux
Description-Content-Type: text/markdown
License-File: LICENSE

# Installation instructions

[pystaq](https://github.com/softwareQinc/staq/blob/main/pystaq/) is a Python 3
wrapper for **staq**. pystaq can be installed using `pip`

```
pip install git+https://github.com/softwareQinc/staq
```

## Creating python stubs for IDE autocompletion and static type checking

In case autocompletion (or static type checking via [mypy](https://www.mypy-lang.org/))
does not work properly in your editor/IDE, you may need to create python stubs
for the package. To do this, execute

```shell
mkdir ~/python_stubs
export MYPATH=$MYPATH:~/python_subs # put this in your .profile or .bashrc
. ~/venv/bin/activate
stubgen -p pystaq -o ~/python_stubs
ln -s ~/python_stubs/pystaq.pyi ~/venv/lib/python3.11/site-packages
```

In the above, we assumed that your platform is UNIX/UNIX-like and that you have
pystaq installed in a virtual environment under `~/venv`. Please modify
accordingly on your system.

## Overview

To parse a circuit, use the function `pystaq.parse_file`, which takes a file path as input, or `pystaq.parse_str`, which accepts an OpenQASM 2.0 program string.

The library provides the following tools:

```
desugar
inline
synthesize_oracles
simplify
rotation_fold
cnot_resynth
map
get_resources
output_cirq
output_projectq
output_qsharp
output_quil
grid_synth
qasm_synth
lattice_surgery
```

Each function takes as input a parsed program, followed by any options supported by the corresponding staq tool.

---

Example:

```
>>> import pystaq

>>> p = pystaq.parse_str('''
OPENQASM 2.0;
include "qelib1.inc";

qreg q[2];
gate cphase(theta) a,b {
  rz(theta/2) a;
  rz(theta/2) b;
  cx a,b;
  rz(-theta/2) b;
  cx a,b;
}
cphase(pi/4) q[0],q[1];
''')

>>> pystaq.inline(p, clear_decls=True)

>>> p
OPENQASM 2.0;
include "qelib1.inc";

qreg q[2];
rz((pi/4)/2) q[0];
rz((pi/4)/2) q[1];
cx q[0],q[1];
rz(-(pi/4)/2) q[1];
cx q[0],q[1];
```

## Device generator

The `pystaq.Device` class can be used to create custom devices for mapping. It has the methods `add_edge` and `set_fidelity`.

---

Example:

```python3
import pystaq
dev = pystaq.Device(4)           # 4 qubits
dev.add_edge(0, 1)               # default is undirected, with fidelity = FIDELITY_1 from staq
dev.add_edge(2, 3, fidelity=0.8, directed=True)
dev.set_fidelity(0, 0.9)         # single qubit fidelity
with open('device.json', 'w') as f:
    f.write(str(dev))
```

This produces the following `device.json` file, which can then be used by `pystaq.map`:

```js
{
  "couplings": [
    {
      "control": 0,
      "target": 1
    },
    {
      "control": 1,
      "target": 0
    },
    {
      "control": 2,
      "fidelity": 0.8,
      "target": 3
    }
  ],
  "name": "Custom Device",
  "qubits": [
    {
      "fidelity": 0.9,
      "id": 0
    },
    {
      "id": 1
    },
    {
      "id": 2
    },
    {
      "id": 3
    }
  ]
}
```

## Custom Bindings

pystaq was created using pybind11. See [`pystaq/staq_wrapper.cpp`](https://github.com/softwareQinc/staq/blob/main/pystaq/staq_wrapper.cpp) for many examples of how to wrap a circuit transformation.

For more details, see also our Quantum++ wrapper [pyqpp](https://github.com/softwareQinc/qpp/wiki/8.-pyqpp#custom-bindings).

## Instructions for developers
How to build pystaq and how to use it:
- in the root folder use the following command to build the pystaq `python3 setup.py build`
- always in the root folder use the following command to install pystaq for the user `python3 setup.py install --user`. If you have installed before pystaq via pip, you need to uninstall it, otherwise when you will import it in the python file the one that will be used will be the installed via pip and not the one that you have built.
- When you launch the python program is important that you are in the same directory of it. Otherwise there could be problem of scoping with arguments and other variables (for example json file of the backend that you want to use). All the arguments must be available in the folder in which there is the python file that you want to run.

How the metrics works: in order to make possible to implements all the methods that are related with the metrics collection inside of pystaq I created a small helper that provides access to the `qasm_cplus.py`. I found it to be the most convient way because basically we are moving python code to c++ and the again to python. Thanks to this intermediates step everything can be handle more properly. 
This is the final result: `metrics.py` ---> `staq_wrapper.cpp` ---> `helper.py` ---> `qasm_cplus.py` 

### Other Information about how metrics works:
Not in every program you need to pass tha param `qasm=` as a file. To be clear: this `qasm="bell_state.qasm"` not work in every case. sometimes, like for example with `OpenQASMetric.py`, you need to write directly the qasm code, like: `qasm='''OPENQASM 2.0;include "qelib1.inc";qreg q[2];creg c[2];reset q[0];h q[0];reset q[1];cx q[0],q[1];h q[0];h q[1];measure q[0] -> c[0];measure q[1] -> c[1];'''`.

It really depends from each case and you need to test it. I am leaving on purpose some example at the end of each file, so it is clear how you can call all the method for the evaluation. You are welcome.
